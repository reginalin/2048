{"ast":null,"code":"import React from 'react';\nimport PropTypes from 'prop-types';\nimport { canUseDOM } from 'exenv';\n/**\n * Key event names.\n */\n\nvar KEYDOWN = 'keydown';\nvar KEYPRESS = 'keypress';\nvar KEYUP = 'keyup';\nvar NORMALIZED_KEYS = {\n  Esc: 'Escape',\n  Spacebar: ' ',\n  Left: 'ArrowLeft',\n  Up: 'ArrowUp',\n  Right: 'ArrowRight',\n  Down: 'ArrowDown',\n  Del: 'Delete',\n  Win: 'OS',\n  Menu: 'ContextMenu',\n  Apps: 'ContextMenu',\n  Scroll: 'ScrollLock',\n  MozPrintableKey: 'Unidentified'\n};\nvar KEY_CODE_KEYS = {\n  '8': 'Backspace',\n  '9': 'Tab',\n  '12': 'Clear',\n  '13': 'Enter',\n  '16': 'Shift',\n  '17': 'Control',\n  '18': 'Alt',\n  '19': 'Pause',\n  '20': 'CapsLock',\n  '27': 'Escape',\n  '32': ' ',\n  '33': 'PageUp',\n  '34': 'PageDown',\n  '35': 'End',\n  '36': 'Home',\n  '37': 'ArrowLeft',\n  '38': 'ArrowUp',\n  '39': 'ArrowRight',\n  '40': 'ArrowDown',\n  '45': 'Insert',\n  '46': 'Delete',\n  '112': 'F1',\n  '113': 'F2',\n  '114': 'F3',\n  '115': 'F4',\n  '116': 'F5',\n  '117': 'F6',\n  '118': 'F7',\n  '119': 'F8',\n  '120': 'F9',\n  '121': 'F10',\n  '122': 'F11',\n  '123': 'F12',\n  '144': 'NumLock',\n  '145': 'ScrollLock',\n  '224': 'Meta'\n};\n/**\n * Check if `given` element is an input / textarea form element or acts as one.\n */\n\nfunction isInput(element) {\n  if (!element) {\n    return false;\n  }\n\n  var tagName = element.tagName;\n  var editable = isContentEditable(element);\n  return tagName === 'INPUT' || tagName === 'TEXTAREA' || editable;\n}\n\nfunction isContentEditable(element) {\n  if (typeof element.getAttribute !== 'function') {\n    return false;\n  }\n\n  return !!element.getAttribute('contenteditable');\n}\n/**\n * Matches an event against a given keyboard key.\n */\n\n\nfunction matchesElementOrArray(a, b) {\n  if (Array.isArray(a)) {\n    return a.includes(b);\n  }\n\n  return a === b;\n}\n\nfunction matchesKeyboardEvent(event, _ref) {\n  var keyCode = _ref.keyCode,\n      keyValue = _ref.keyValue,\n      code = _ref.code;\n\n  if (!isNullOrUndefined(keyValue)) {\n    var value = eventKey(event);\n\n    if (matchesElementOrArray(keyValue, value)) {\n      return true;\n    }\n  }\n\n  if (!isNullOrUndefined(code)) {\n    if (matchesElementOrArray(code, event.code)) {\n      return true;\n    }\n  }\n\n  if (!isNullOrUndefined(keyCode)) {\n    // Firefox handles keyCode through which\n    var keyCodeTarget = event.keyCode || event.which;\n\n    if (matchesElementOrArray(keyCode, keyCodeTarget)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isNullOrUndefined(value) {\n  return value === undefined || value === null;\n}\n\nfunction eventKey(event) {\n  var key = event.key,\n      keyCode = event.keyCode,\n      type = event.type;\n\n  if (key) {\n    var normalizedKey = NORMALIZED_KEYS[key] || key;\n\n    if (normalizedKey !== 'Unidentified') {\n      return normalizedKey;\n    }\n  }\n\n  if (type === KEYPRESS) {\n    var charCode = eventCharCode(event);\n    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);\n  }\n\n  if (type === KEYDOWN || type === KEYUP) {\n    return KEY_CODE_KEYS[String(keyCode)] || 'Unidentified';\n  }\n\n  return '';\n}\n\nfunction eventCharCode(event) {\n  var charCode = event.charCode,\n      keyCode = event.keyCode;\n\n  if ('charCode' in event) {\n    if (charCode === 0 && keyCode === 13) {\n      return 13;\n    }\n  } else {\n    charCode = keyCode;\n  }\n\n  if (charCode >= 32 || charCode === 13) {\n    return charCode;\n  }\n\n  return 0;\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar KeyHandler = function (_React$Component) {\n  inherits(KeyHandler, _React$Component);\n  createClass(KeyHandler, [{\n    key: 'shouldComponentUpdate',\n    value: function shouldComponentUpdate() {\n      return false;\n    }\n  }]);\n\n  function KeyHandler(props) {\n    classCallCheck(this, KeyHandler);\n    /* eslint-disable no-console */\n\n    var _this = possibleConstructorReturn(this, (KeyHandler.__proto__ || Object.getPrototypeOf(KeyHandler)).call(this, props));\n\n    _this.handleKey = function (event) {\n      var _this$props = _this.props,\n          keyValue = _this$props.keyValue,\n          keyCode = _this$props.keyCode,\n          code = _this$props.code,\n          onKeyHandle = _this$props.onKeyHandle;\n\n      if (!onKeyHandle) {\n        return;\n      }\n\n      var target = event.target;\n\n      if (target instanceof window.HTMLElement && isInput(target)) {\n        return;\n      }\n\n      if (!matchesKeyboardEvent(event, {\n        keyValue: keyValue,\n        keyCode: keyCode,\n        code: code\n      })) {\n        return;\n      }\n\n      onKeyHandle(event);\n    };\n\n    if (props.keyCode) {\n      console.warn('Warning: Deprecated propType: `keyCode` is deprecated in favour of `code` for `KeyHandler`.');\n    }\n\n    if (!props.keyValue && !props.keyCode && !props.code) {\n      console.error('Warning: Failed propType: Missing prop `code`, `keyValue` or `keyCode` for `KeyHandler`.');\n    }\n    /* eslint-enable */\n\n\n    return _this;\n  }\n\n  createClass(KeyHandler, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      if (!canUseDOM) return;\n      window.document.addEventListener(this.props.keyEventName, this.handleKey);\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (!canUseDOM) return;\n      window.document.removeEventListener(this.props.keyEventName, this.handleKey);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      return null;\n    }\n  }]);\n  return KeyHandler;\n}(React.Component);\n\nKeyHandler.propTypes = {\n  keyValue: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n  keyCode: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n  code: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n  keyEventName: PropTypes.oneOf([KEYDOWN, KEYPRESS, KEYUP]),\n  onKeyHandle: PropTypes.func\n};\nKeyHandler.defaultProps = {\n  keyEventName: KEYUP\n};\n\nfunction keyHandleDecorator(matcher) {\n  return function (props) {\n    var _ref = props || {},\n        keyValue = _ref.keyValue,\n        keyCode = _ref.keyCode,\n        code = _ref.code,\n        keyEventName = _ref.keyEventName;\n\n    return function (Component) {\n      return function (_React$Component) {\n        inherits(KeyHandleDecorator, _React$Component);\n\n        function KeyHandleDecorator() {\n          var _ref2;\n\n          var _temp, _this, _ret;\n\n          classCallCheck(this, KeyHandleDecorator);\n\n          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref2 = KeyHandleDecorator.__proto__ || Object.getPrototypeOf(KeyHandleDecorator)).call.apply(_ref2, [this].concat(args))), _this), _this.state = {\n            keyCode: null,\n            keyValue: null,\n            code: null\n          }, _this.handleKey = function (event) {\n            if (matcher && matcher(event, _this.state)) {\n              _this.setState({\n                keyValue: null,\n                keyCode: null\n              });\n\n              return;\n            }\n\n            _this.setState({\n              keyValue: eventKey(event),\n              keyCode: event.keyCode\n            });\n          }, _temp), possibleConstructorReturn(_this, _ret);\n        }\n\n        createClass(KeyHandleDecorator, [{\n          key: 'render',\n          value: function render() {\n            return React.createElement(React.Fragment, null, React.createElement(KeyHandler, {\n              keyValue: keyValue,\n              keyCode: keyCode,\n              code: code,\n              keyEventName: keyEventName,\n              onKeyHandle: this.handleKey\n            }), React.createElement(Component, _extends({}, this.props, this.state)));\n          }\n        }]);\n        return KeyHandleDecorator;\n      }(React.Component);\n    };\n  };\n}\n\nvar keyHandler = keyHandleDecorator();\nvar keyToggleHandler = keyHandleDecorator(matchesKeyboardEvent);\nexport default KeyHandler;\nexport { KEYDOWN, KEYPRESS, KEYUP, keyHandleDecorator, keyToggleHandler, keyHandler };","map":null,"metadata":{},"sourceType":"module"}